<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"graph_theory_component_array.js.html":{"id":"graph_theory_component_array.js.html","title":"Source: graph_theory/component_array.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/component_array.js var NodeArray = require('./node_array'); var RobustArray = require('./robust_array'); /** * represents a set of NodeArrays * @exports ComponentArray * @constructor * @memberOf! module:GraphTheory * @extends RobustArray */ class ComponentArray extends RobustArray.SetifyType(NodeArray) { /** * Places NodeArray (and associated dependencies) in the Prototype chain for classical extension * @param {Function} NAClass the NodeArray class this Class depends upon * @return {Function} */ static assignNodeArray(NAClass = NodeArray) { this.prototype.NodeArray = NAClass; this.prototype.Node = NAClass.prototype.Node; return this; } /** * adds a component to the graph if not present * @param {Component} compArg */ push(compArg) { return this.integrateComponent(compArg) || super.push(compArg); } /** * checks if any components (excluding the argument) share nodes with the argument * @param {Component} compArg * @return {Boolean} */ hasIntersectingComponent(compArg) { return this.excludeElement(compArg).some(currComp =&gt; currComp.intersects(compArg)); } /** * returns the first component (excluding the argument) which intersect with compArg * @param {Component} compArg the component to be checked * @return {Component} the first intersecting component */ findIntersectingComponent(compArg) { return this.excludeElement(compArg).find(currComp =&gt; currComp.intersects(compArg)); } /** * combines the nodes of two intersecting components into orrgComp, and removes newComp * @param {Component} origComp the component taking precedence * @param {Component} newComp the component to be removed */ mergeComponents(origComp, newComp) { this.removeElement(newComp); return origComp.unionize(newComp); } /** * integrates a component into any of the arrays intersecting components * @param {Component} compArg */ integrateComponent(compArg) { let iComp = this.findIntersectingComponent(compArg); return (!!iComp) &amp;&amp; this.mergeComponents(iComp, compArg); } }; ComponentArray.assignNodeArray(); /** * [An Set of mutually exclusive NodeArrays]{@link module:GraphTheory.ComponentArray} * @typedef {module:GraphTheory.ComponentArray} ComponentArray */ module.exports = ComponentArray; × Search results Close "},"graph_theory_directed_edge.js.html":{"id":"graph_theory_directed_edge.js.html","title":"Source: graph_theory/directed_edge.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/directed_edge.js var Node = require('./node'); var NodeArray = require('./node_array'); var Edge = require('./edge'); /** * represents a connection between nodes * @exports DirectedEdge * @constructor * @memberOf! module:GraphTheory */ class DirectedEdge extends Edge { constructor(src = new Node(), dest = new Node(), weight = 0) { super(src, dest, weight); this.source = src; this.dest = dest; } isEquivalent(edgeArg) { return (edgeArg instanceof DirectedEdge) ? super.isEquivalent(edgeArg) : false; } } /** * [A DirectedEdge]{@link module:GraphTheory.DirectedEdge} * @typedef {module:GraphTheory.DirectedEdge} DirectedEdge */ module.exports = DirectedEdge; × Search results Close "},"graph_theory_edge.js.html":{"id":"graph_theory_edge.js.html","title":"Source: graph_theory/edge.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/edge.js var Node = require('./node'); var NodeArray = require('./node_array'); /** * represents a connection between nodes * @exports Edge * @constructor * @memberOf! module:GraphTheory */ class Edge { /** * Places NodeArray (and associated dependencies) in the Prototype chain for runtime extension * @param {Function} NAClass the NodeArray class this Class depends upon * @return {Function} */ static assignNodeArray(NAClass = NodeArray) { this.prototype.NodeArray = NAClass; this.prototype.Node = NAClass.prototype.Node; return this; } /** * creates an edge connecting two nodes * @param {Node} n1 * @param {Node} n2 * @param {Number} [weight=0] the value associated with the edge * @return {Edge} the new edge */ constructor(n1 = new Node(), n2 = new Node(), weight = 0) { /** * the weight of the edge * @type {Number} */ this.weight = weight; this.establishNodes(n1, n2); this.setLabel(); } establishNodes(n1, n2) { /** * an array of nodes * @type {NodeArray} */ this.nodes = this.NodeArray.of(n1, n2); } setLabel() { /** * an identifier for the Edge * @type {String} */ this.label = `${this.nodes[0].label}_${this.nodes[1].label}`; } /** * checks the equivalence (by nodes) of this edge against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ isEquivalent(edgeArg) { return this.hasSameNodes(edgeArg); } /** * checks the equivalence of this edge's label against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameName(edgeArg) { return (this.label) ? this.label === edgeArg.label : false; } /** * checks the equivalence of this edges nodes against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameNodes(edgeArg) { return this.nodes.isEquivalent(edgeArg.nodes); } /** * Checks for the presence of a node in this edge * @param {Node} nodeArg * @return {Boolean} */ containsNode(nodeArg) { return this.nodes.contains(nodeArg); } /** * @param {Node} nodeArg * @return {Node} the neighbor */ getNeighbor(nodeArg) { return this.nodes.find(currNode =&gt; currNode != nodeArg); } /** * typecasts the neighboring node as a NodeArray with a single element (for method chaining) * @param {Node} nodeArg * @return {NodeArray} an Array of the neighboring node */ nabeArray(nodeArg) { return this.nodes.excludeElement(nodeArg); } } Edge.assignNodeArray(); /** * [An Edge]{@link module:GraphTheory.Edge} * @typedef {module:GraphTheory.Edge} Edge */ module.exports = Edge; × Search results Close "},"graph_theory_edge_array.js.html":{"id":"graph_theory_edge_array.js.html","title":"Source: graph_theory/edge_array.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/edge_array.js var Node = require('./node'); var NodeArray = require('./node_array'); var Edge = require('./edge'); // var DirectedEdge = require('./directedEdge'); var RobustArray = require('./robust_array'); /** * represents a set of Edges * @exports EdgeArray * @constructor * @memberOf! module:GraphTheory * @extends {RobustArray} */ class EdgeArray extends RobustArray.SetifyType(Edge) { /** * defines EdgeClass (and associated dependencies) on the Prototype chain for runtime extension * @param {Function} EClass the Edge function this class depends upon * @return {Function} EdgeArray the updated EdgeArray class */ static assignEdge(EClass = Edge) { this.prototype.Edge = EClass; this.prototype.NodeArray = EClass.prototype.NodeArray; this.prototype.Node = EClass.prototype.Node; return this; } /** * Filters the edges by those which contain the specified node * @param {Node} nArg the node in question * @return {EdgeArray} the filtered array */ edgesWithNode(nArg) { return this.filter(e =&gt; e.containsNode(nArg)); } /**/ edgeByNodes(n1, n2) { return this.find(e =&gt; (e.containsNode(n1) &amp;&amp; e.containsNode(n2))); } /** * * @param {NodeArray} nArr the nodes to be matched against * @return {EdgeArray} the edges intersecting nArr */ edgesByArray(nArr) { return nArr.reduce((eArr, nNode) =&gt; eArr.unionize(this.edgesWithNode(nNode)), new this.constructor()); } /** * @return {NodeArray} all of the nodes in this array of edges */ getNodes() { return this.reduce((prev, succ) =&gt; prev.unionize(succ.nodes), new this.NodeArray); } /** * @param {NodeArray} nArg the node to be matched against * @return {NodeArray} all of the nodes contained in this array */ getNeighbors(nArg) { return this.edgesWithNode(nArg).reduce((prev, succ) =&gt; prev.unionize(succ.nabeArray(nArg)), new this.NodeArray); } } EdgeArray.assignEdge(); /** * [An EdgeArray]{@link module:GraphTheory.EdgeArray} * @typedef {module:GraphTheory.EdgeArray} EdgeArray */ module.exports = EdgeArray; × Search results Close "},"graph_theory_graph.js.html":{"id":"graph_theory_graph.js.html","title":"Source: graph_theory/graph.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/graph.js var Node = require('./node'); var NodeArray = require('./node_array'); var Edge = require('./edge'); var EdgeArray = require('./edge_array'); var ComponentArray = require('./component_array'); /** * represents a Graph * @exports Graph * @constructor * @memberOf! module:GraphTheory */ class Graph { /** * defines EdgeArrayClass (and associated dependencies) on the Prototype chain for runtime extension * @param {Function} EAClass the EdgeArray function this class depends upon * @return {Function} the updated Graph class */ static assignEdgeArray(EAClass = EdgeArray) { this.prototype.EdgeArray = EAClass; this.prototype.Edge = EAClass.prototype.Edge; this.prototype.NodeArray = EAClass.prototype.NodeArray; this.prototype.Node = EAClass.prototype.Node; this.prototype.ComponentArray = ComponentArray.assignNodeArray(EAClass.prototype.NodeArray); return this; } /** * creates a Graph object * @param {NodeArray} nodes the graph's nodes * @return {Graph} */ constructor(nodes) { this.establishNodes(nodes); this.establishEdges(); this.establishComponents(); } /** * assigns/typecasts the nodes attibute * @param {?NodeArray} nArr */ establishNodes(nArr) { /** * the graph's nodes * @type {NodeArray} */ this.nodes = nArr ? this.NodeArray.from(nArr) : new this.NodeArray; } /** * assigns/typecasts the edges attibute */ establishEdges() { /** * the graph's edges * @type {EdgeArray} */ this.edges = new this.EdgeArray; } /** * assigns/typecasts the components attibute */ establishComponents() { /** * the graph's components * @type {ComponentArray} */ this.components = new this.ComponentArray(); } /** * @see [delegated to NodeArray#push] {@link module:GraphTheory.NodeArray#push} */ addNode(node) { this.nodes.push(node); return this; } /** * @see [delegated NodeArray#contains] {@link module:GraphTheory.NodeArray#contains} */ containsNode(argNode) { return this.nodes.contains(argNode); } /** * removes all edges associated with the argument, then calls removes the node * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#removeElement} * @see [remove edge] {@link module:GraphTheory.Graph#removeEdge} */ removeNode(nodeArg) { this.edgesWithNode(nodeArg).forEach(e =&gt; this.removeEdge(e)); this.nodes.removeElement(nodeArg); return this; } /** * removes all edges associated with the argument, then removes all nodes the node * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#clear} * @see [remove edge] {@link module:GraphTheory.Graph#removeEdge} * @return {Graph} the current graph */ clearNodes() { this.nodes.forEach(n =&gt; this.removeNode(n)); this.nodes.clear(); return this; } /** * clears the nodes and reassigns them to narr * @param {NodeArray} nArr * @return {Graph} the current graph */ setNodes(nArr) { this.clearNodes(); this.nodes = nArr; return this; } /** * merges the nodes from the argument into the current graphs nodes * @param {NodeArray} nArr nodes to merge * @return {Graph} the current graph */ copyNodes(nArr) { this.nodes.unionize(nArr); return this; } /** * @param {Node} nodeArg source node * @return {EdgeArray} the edges connected to source */ edgesWithNode(nodeArg) { return this.edges.edgesWithNode(nodeArg); } /** * creates a new edge given two nodes * @param {Node} sNode source node * @param {Node} dNode destination node * @param {Number} weight weight of new edge * @return {Edge} the newly added edge */ createEdge(sNode, dNode, weight) { this.addEdge(new this.Edge(sNode, dNode, weight)); return this.edges.edgeByNodes(sNode, dNode); } /** * copies the nodes from the edge, then adds it to the edges array * @param {Edge} edgeArg * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#removeElement} * @return {Graph} the current graph */ addEdge(edgeArg) { this.copyNodes(edgeArg.nodes); this.edges.push(edgeArg); return this; } /** * @see [delegated to EdgeArray#push] {@link module:GraphTheory.EdgeArray#push} */ containsEdge(argEdge) { return this.edges.contains(argEdge); } /** * @see [delegated to EdgeArray#removeElement] {@link module:GraphTheory.EdgeArray#removeElement} */ removeEdge(argEdge) { this.edges.removeElement(argEdge); } /** * @see [delegated to EdgeArray#clear] {@link module:GraphTheory.EdgeArray#clear} * @return {Graph} the current graph */ clearEdges() { this.edges.clear(); return this; } /** * clears and reassigns nodes to those of the edge array, and sets the edges * functions basically as a graph reset, an easy way to explore a graph from different angles * @see [calls EdgeArray#getNodes] {@link module:GraphTheory.EdgeArray#getNodes} * @param {EdgeArray} eArr * @return {Graph} the modified graph */ setEdges(eArr) { let eNodes = eArr.getNodes(); this.setNodes(eNodes); this.edges = eArr; return this; } /** * copies and merges the nodes from the edgeArray, then merges the edges into the current graph * @param {EdgeArray} eArr * @return {Graph} the modified graph */ copyEdges(eArr) { let eNodes = eArr.getNodes(); this.copyNodes(eNodes); this.edges.unionize(eArr); return this; } /** * creates a new graph * @param {?NodeArray} nArr a potential inital set of Nodes * @return {Graph} a new Graph instance */ subGraph(nArr) { return new this.constructor(nArr); } /** * creates a new graph, and sets its edges, * useful for exploring a graph based on different connections * @param {EdgeArray} [eArr = this.edges] a potential inital set of Edges * @return {Graph} a new Graph instance */ subGraphByEdges(eArr = this.edges) { return this.subGraph().copyEdges(eArr); } /** * * @param {Node} nodeArg the source node * @return {NodeArray} the neighboring nodes */ getNeighbors(nodeArg) { return this.edges.getNeighbors(nodeArg); } /** * typecasts a path to a NodeArray * @param {Map} pathArg an ordered sequence of nodes with predecessors and path weights * @return {NodeArray} An array of the nodes */ pathNodes(pathArg) { return this.NodeArray.from([...pathArg.keys()]); } /** * returns all of the Edges connected to a node whose neighbors have yet to be visited * @param {Node} nodeArg the node * @param {NodeArray} compArg the component being explored * @return {EdgeArray} the edges with unexplored nodes */ getUnvisitedEdges(nodeArg, compArg) { let unArr = this.getUnvisitedNeighbors(nodeArg, compArg); return this.edgesWithNode(nodeArg).edgesByArray(unArr); } /** * returns all of the nodes neighbors not yet part explored in the component * @param {Node} nodeArg * @param {NodeArray} compArg the explored component * @return {NodeArray} unexplored nodes */ getUnvisitedNeighbors(nodeArg, compArg) { return this.getNeighbors(nodeArg).difference(compArg); } /** * adds all unvisited nodes in the path to the specified component * @param {Map} pathArg the path to be explored */ visitPath(pathArg) { let pNodes = this.pathNodes(pathArg); let lastNode = pNodes.pop(); let nextEdges = this.getUnvisitedEdges(lastNode, pNodes); if (nextEdges.length === 0) { return pathArg; } else { let predWeight = pathArg.get(lastNode).pathWeight; let predCount = pathArg.get(lastNode).edgeCount; nextEdges.forEach(currEdge =&gt; { let nabe = currEdge.getNeighbor(lastNode); pathArg.set(nabe, { pred: lastNode, edgeCount: predCount + 1, pathWeight: predWeight + currEdge.weight }); this.visitPath(pathArg); }); } return pathArg; } /** * depth first search, initializes a new component of reachable nodes, * and constructs a path to each of those node from the initNode * @param {Node} initNode the source node * @return {Map} a key-value store of nodes and edge distances */ dfs(initNode) { let path = new Map(); path.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); this.visitPath(path); let pComp = this.pathNodes(path); this.addComponent(pComp); return path; } containsComponent(compArg) { return this.components.contains(compArg); } /** * adds a component to the graph if not present * @param {NodeArray} compArg */ addComponent(compArg) { this.components.push(compArg); } removeComponent(compArg) { this.components.removeElement(compArg); } /** * returns any current components which intersect with the specified component * @param {NodeArray} compArg the component to be checked * @return {NodeArray} the first intersecting component */ findIntersectingComponent(compArg) { return this.components.findIntersectingComponent(compArg); } /** * combines the nodes of two intersecting components * @param {NodeArray} origComp * @param {NodeArray} newComp */ mergeComponents(origComp, newComp) { return this.components.mergeComponents(origComp, newComp); } /** * integrates a component into any of the graphs intersectung components * @param {NodeArray} compArg */ integrateComponent(compArg) { return this.components.integrateComponent(compArg); } /** * checks if any current components share nodes with the argument * @param {NodeArray} compArg * @return {Boolean} */ hasIntersectingComponent(compArg) { return this.components.some(currComp =&gt; currComp.intersects(compArg)); } /** * breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node * @param {Node} initNode inital node * @return {Map} a key-value store of nodes and edge distances */ bfs(initNode = this.nodes[0]) { var bPath = new Map().set(initNode, { pred: null, pathWeight: 0, edgeCount: 0 }); var bQueue = this.NodeArray.of(initNode); while (bQueue.length &gt; 0) { let currN = bQueue.shift(); var bNodes = this.pathNodes(bPath); let currEdges = this.getUnvisitedEdges(currN, bNodes); let prNode = bPath.get(currN); currEdges.forEach((nEdge) =&gt; { let nNode = nEdge.getNeighbor(currN); bPath.set(nNode, { pred: currN, edgeCount: prNode.edgeCount + 1, pathWeight: prNode.pathWeight + nEdge.weight }); bQueue.push(nNode); }); } this.addComponent(bNodes); return bPath; } /** * check if a path exists between two nodes * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Boolean} does a path exist between the two nodes */ hasPath(initNode, termNode) { return this.bfs(initNode).has(termNode); } /** * performs dijkstras algorithm for shortest paths to all nodes reachable from initNode * @param {Node} initNode the initial node * @return {Map} a sequence of nodes and their distances */ dijkstra(initNode = this.nodes[0]) { var reachables = this.bfs(initNode); var inspectionQueue = this.NodeArray.of(initNode); var solutionSet = new Map().set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); while (inspectionQueue.length &gt; 0) { var currN = inspectionQueue.shift(); var currEdges = this.edgesWithNode(currN); currEdges.forEach((tempEdge) =&gt; { let nNode = tempEdge.getNeighbor(currN); var rNodeEntry = reachables.get(nNode); var currWeight = rNodeEntry.pathWeight; var sPred = solutionSet.get(currN); var dijkstraWeight = sPred.pathWeight + tempEdge.weight; let dMap = { pred: currN, edgeCount: sPred.edgeCount + 1, pathWeight: dijkstraWeight }; let sMap = (dijkstraWeight &lt; currWeight) ? dMap : rNodeEntry; if (!solutionSet.has(nNode)) { inspectionQueue.push(nNode); solutionSet.set(nNode, sMap); } }); } return solutionSet; } /** * composes the shortest path between two nodes by backtracing from dijkstra * @param {Node} initNode * @param {Node} termNode * @return {?Map} path of nodes */ shortestPath(initNode, termNode) { if (!this.hasPath(initNode, termNode)) { return false; } else { let dijkMap = this.dijkstra(initNode); let currN = termNode; let currEntry = dijkMap.get(currN); let predN = currEntry.pred; let path = new Map(); while (currN != initNode) { path.set(currN, currEntry); currN = predN; currEntry = dijkMap.get(currN); predN = currEntry.pred; } return path; } } }; Graph.assignEdgeArray(); module.exports = Graph; /** * [A Graph]{@link module:GraphTheory.Graph} * @typedef {module:GraphTheory.Graph} Graph */ × Search results Close "},"graph_theory.js.html":{"id":"graph_theory.js.html","title":"Source: graph_theory.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory.js /** * @module GraphTheory */ exports.Node = require('./graph_theory/node'); exports.RobustArray = require('./graph_theory/robust_array'); exports.NodeArray = require('./graph_theory/node_array'); exports.DirectedEdge = require('./graph_theory/directed_edge'); exports.Edge = require('./graph_theory/edge'); exports.EdgeArray = require('./graph_theory/edge_array'); exports.ComponentArray = require('./graph_theory/component_array'); exports.Graph = require('./graph_theory/graph'); × Search results Close "},"graph_theory_node.js.html":{"id":"graph_theory_node.js.html","title":"Source: graph_theory/node.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/node.js /** * represent a Node * @exports Node * @constructor * @memberOf module:GraphTheory * @param {String} label [label property]{@link module:GraphTheory.Node#label} * @param {Object} data the nodes data */ class Node { constructor(label, data) { this.setLabel(label); this.setData(data); } /** * sets the node's label attribute * @param {String} lbl */ setLabel(lbl) { /** * the node identifier * @type {String} */ return this.label = lbl; } /** * sets the node's data attribute * @param {Object} d */ setData(d) { /** * the node data * @type {Object} */ return this.data = d || {}; } /** * Checks for identity via label attribute * @param {Node} newNode the node to be compared * @return {Boolean} */ isEquivalent(newNode) { return this.label === newNode.label; } } /** * [A Node]{@link module:GraphTheory.Node} * @typedef {module:GraphTheory.Node} Node */ module.exports = Node; × Search results Close "},"graph_theory_node_array.js.html":{"id":"graph_theory_node_array.js.html","title":"Source: graph_theory/node_array.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/node_array.js var Node = require('./node'); var RobustArray = require('./robust_array'); /** * represents a set of Nodes * @exports NodeArray * @constructor * @extends {RobustArray} * @memberOf! module:GraphTheory */ class NodeArray extends RobustArray.SetifyType(Node) { /** * defines NodeClass on the Prototype chain for runtime extension * @param {Function} NClass the Node function this class depends upon * @return {Function} the updated NodeArray class */ static assignNode(nClass = Node) { this.prototype.Node = nClass; } }; NodeArray.assignNode(); /** * [A NodeArray]{@link module:GraphTheory.NodeArray} * @typedef {module:GraphTheory.NodeArray} NodeArray */ module.exports = NodeArray; × Search results Close "},"graph_theory_robust_array.js.html":{"id":"graph_theory_robust_array.js.html","title":"Source: graph_theory/robust_array.js","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/robust_array.js /** * Constructs [An Type-specific Array Subclass]{@link module:GraphTheory.RobustArray} * @memberOf! module:GraphTheory * @param {Function} BaseType the data type/Class of objects stored in this array * @return {Function} [The resulting RobustArray Class]{@link module:GraphTheory.RobustArray} */ function RobustArrayFactory(BaseType) { /** * a type-specific array class implementing set theory * @exports RobustArray * @constructor * @memberOf! module:GraphTheory * @extends Array */ let RobustArray = class extends Array { /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks the data type of the new element * @param {Object} argObj * @return {Boolean} */ isValid(argObj) { return argObj instanceof BaseType; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @return {Boolean} is the array length 0 */ isEmpty() { return this.length === 0; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks for presence of an element in this set * @param {Object} argObj * @return {Boolean} */ contains(argObj) { return this.some(el =&gt; el.isEquivalent(argObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * appends an element to this array if passes the type validator and is not already present * @param {Object} argObj * @return {RobustArray} the current array */ push(argObj) { if ((this.isValid(argObj) &amp;&amp; !(this.contains(argObj)))) { super.push(argObj); } return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#filter * @param {...Object} args JS Native Array#filter arguments * @return {RobustArray} */ filter(...args) { return this.constructor.from(super.filter(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#slice * @param {...Object} args JS Native Array#slice arguments * @return {RobustArray} */ slice(...args) { return this.constructor.from(super.slice(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#concat * @param {...Object} args JS Native Array#concat arguments * @return {RobustArray} */ concat(...args) { return this.constructor.from(super.concat(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#splice * @param {...Object} args JS Native Array#splice arguments * @return {RobustArray} */ splice(...args) { return this.constructor.from(super.splice(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray * @return {Boolean} do the arrays have the same length */ hasSameSize(altArray) { return this.length === altArray.length; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray * @return {Boolean} does the altArray contain every element of the receiver */ isSubset(altArray) { return this.every(myObj =&gt; altArray.contains(myObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray * @return {Boolean} do the argument nad receiver share length and elements */ isEquivalent(altArray) { return (this.hasSameSize(altArray) &amp;&amp; this.isSubset(altArray)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns the first element which is equivalent to the argument * @param {RobustArray} altArray * @return {?Object} */ findEquivalentElement(argObj) { return this.find(el =&gt; el.isEquivalent(argObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * removes the argument from the array * @param {Object} argObj * @return {(Object|Boolean)} */ removeElement(argObj) { let eqIdx = this.findIndex(el =&gt; el.isEquivalent(argObj)); return eqIdx &gt; -1 &amp;&amp; this.splice(eqIdx, 1); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * removes all elements from the array * @param {RobustArray} altArray * @return {RobustArray} the newly empty array */ clear() { this.splice(0); return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @return {RobustArray} a copy of this array */ copy() { return this.slice(0); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks for presence of shared elements between two sets * @param {RobustArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currEl =&gt; altArray.contains(currEl) === true); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns an array shared elements between two sets * @param {RobustArray} altArray the array to check * @return {RobustArray} the shared elements */ intersection(altArray) { return this.filter(currEl =&gt; altArray.contains(currEl) === true); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray the array to check * @return {Boolean} does the caller have any element not included in the argument */ hasDistinctElements(altArray) { return this.some(myObj =&gt; !altArray.contains(myObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns an array elements in this array not included in the alternate array * @param {RobustArray} altArray the array to check * @return {RobustArray} the unshared elements */ difference(altArray) { return this.filter(n =&gt; !altArray.contains(n)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns a combined array of elements contained in the receiver or altArray * @param {RobustArray} altArray * @return {RobustArray} */ union(altArray) { let uArray = new this.constructor(); this.forEach(currEl =&gt; uArray.push(currEl)); altArray.forEach(altElem =&gt; uArray.push(altElem)); return uArray; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * combines all the elements from altArray into the receiver * @param {RobustArray} altArray * @return {RobustArray} the receiver */ unionize(altArray) { altArray.difference(this).forEach(dNode =&gt; this.push(dNode)); return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {Object} exElem the element to exclude * @return {RobustArray} all of the elements in this object excluding exElem */ excludeElement(exElem) { return this.filter(el =&gt; el != exElem); } }; /** * [A RobustArray]{@link module:GraphTheory.RobustArray} * @typedef {module:GraphTheory.RobustArray} RobustArray */ return RobustArray; }; /** * [A RobustArrayFactory]{@link module:GraphTheory.RobustArrayFactory} * @typedef {module:GraphTheory.RobustArrayFactory} RobustArrayFactory * @exports RobustArray.SetifyType */ module.exports.SetifyType = RobustArrayFactory; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Global Type Definitions ComponentArray An Set of mutually exclusive NodeArrays Type: module:GraphTheory.ComponentArray Source: graph_theory/component_array.js, line 66 DirectedEdge A DirectedEdge Type: module:GraphTheory.DirectedEdge Source: graph_theory/directed_edge.js, line 22 Edge An Edge Type: module:GraphTheory.Edge Source: graph_theory/edge.js, line 103 EdgeArray An EdgeArray Type: module:GraphTheory.EdgeArray Source: graph_theory/edge_array.js, line 61 Graph A Graph Type: module:GraphTheory.Graph Source: graph_theory/graph.js, line 436 Node A Node Type: module:GraphTheory.Node Source: graph_theory/node.js, line 46 NodeArray A NodeArray Type: module:GraphTheory.NodeArray Source: graph_theory/node_array.js, line 21 RobustArray A RobustArray Type: module:GraphTheory.RobustArray Source: graph_theory/robust_array.js, line 239 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Modules Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Classes Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global × Search results Close "},"module-GraphTheory.html":{"id":"module-GraphTheory.html","title":"Module: GraphTheory","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: GraphTheory Source: graph_theory.js, line 1 Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray Methods &lt;static&gt; RobustArrayFactory(BaseType) Constructs An Type-specific Array Subclass Parameters: Name Type Description BaseType function the data type/Class of objects stored in this array Source: graph_theory/robust_array.js, line 7 Returns: The resulting RobustArray Class Type function × Search results Close "},"module-GraphTheory.ComponentArray.html":{"id":"module-GraphTheory.ComponentArray.html","title":"Class: ComponentArray","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: ComponentArray GraphTheory. ComponentArray represents a set of NodeArrays new ComponentArray() Source: graph_theory/component_array.js, line 10 Extends RobustArray Methods &lt;static&gt; assignNodeArray(NAClass) Places NodeArray (and associated dependencies) in the Prototype chain for classical extension Parameters: Name Type Description NAClass function the NodeArray class this Class depends upon Source: graph_theory/component_array.js, line 17 Returns: Type function findIntersectingComponent(compArg) returns the first component (excluding the argument) which intersect with compArg Parameters: Name Type Description compArg Component the component to be checked Source: graph_theory/component_array.js, line 42 Returns: the first intersecting component Type Component hasIntersectingComponent(compArg) checks if any components (excluding the argument) share nodes with the argument Parameters: Name Type Description compArg Component Source: graph_theory/component_array.js, line 34 Returns: Type Boolean integrateComponent(compArg) integrates a component into any of the arrays intersecting components Parameters: Name Type Description compArg Component Source: graph_theory/component_array.js, line 58 mergeComponents(origComp, newComp) combines the nodes of two intersecting components into orrgComp, and removes newComp Parameters: Name Type Description origComp Component the component taking precedence newComp Component the component to be removed Source: graph_theory/component_array.js, line 50 push(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg Component Source: graph_theory/component_array.js, line 26 × Search results Close "},"module-GraphTheory.DirectedEdge.html":{"id":"module-GraphTheory.DirectedEdge.html","title":"Class: DirectedEdge","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: DirectedEdge GraphTheory. DirectedEdge represents a connection between nodes new DirectedEdge() Source: graph_theory/directed_edge.js, line 11 × Search results Close "},"module-GraphTheory.Edge.html":{"id":"module-GraphTheory.Edge.html","title":"Class: Edge","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Edge GraphTheory. Edge represents a connection between nodes new Edge(n1, n2 [, weight]) creates an edge connecting two nodes Parameters: Name Type Argument Default Description n1 Node n2 Node weight Number &lt;optional&gt; 0 the value associated with the edge Source: graph_theory/edge.js, line 9 Members label :String an identifier for the Edge Type: String Source: graph_theory/edge.js, line 50 nodes :NodeArray an array of nodes Type: NodeArray Source: graph_theory/edge.js, line 43 Methods &lt;static&gt; assignNodeArray(NAClass) Places NodeArray (and associated dependencies) in the Prototype chain for runtime extension Parameters: Name Type Description NAClass function the NodeArray class this Class depends upon Source: graph_theory/edge.js, line 16 Returns: Type function containsNode(nodeArg) Checks for the presence of a node in this edge Parameters: Name Type Description nodeArg Node Source: graph_theory/edge.js, line 82 Returns: Type Boolean getNeighbor(nodeArg) Parameters: Name Type Description nodeArg Node Source: graph_theory/edge.js, line 89 Returns: the neighbor Type Node hasSameName(edgeArg) checks the equivalence of this edge's label against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graph_theory/edge.js, line 66 Returns: Type Boolean hasSameNodes(edgeArg) checks the equivalence of this edges nodes against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graph_theory/edge.js, line 74 Returns: Type Boolean isEquivalent(edgeArg) checks the equivalence (by nodes) of this edge against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graph_theory/edge.js, line 57 Returns: Type Boolean nabeArray(nodeArg) typecasts the neighboring node as a NodeArray with a single element (for method chaining) Parameters: Name Type Description nodeArg Node Source: graph_theory/edge.js, line 97 Returns: an Array of the neighboring node Type NodeArray × Search results Close "},"module-GraphTheory.EdgeArray.html":{"id":"module-GraphTheory.EdgeArray.html","title":"Class: EdgeArray","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: EdgeArray GraphTheory. EdgeArray represents a set of Edges new EdgeArray() Source: graph_theory/edge_array.js, line 13 Extends RobustArray Methods &lt;static&gt; assignEdge(EClass) defines EdgeClass (and associated dependencies) on the Prototype chain for runtime extension Parameters: Name Type Description EClass function the Edge function this class depends upon Source: graph_theory/edge_array.js, line 19 Returns: EdgeArray the updated EdgeArray class Type function edgesByArray(nArr) Parameters: Name Type Description nArr NodeArray the nodes to be matched against Source: graph_theory/edge_array.js, line 42 Returns: the edges intersecting nArr Type EdgeArray edgesWithNode(nArg) Filters the edges by those which contain the specified node Parameters: Name Type Description nArg Node the node in question Source: graph_theory/edge_array.js, line 30 Returns: the filtered array Type EdgeArray getNeighbors(nArg) Parameters: Name Type Description nArg NodeArray the node to be matched against Source: graph_theory/edge_array.js, line 55 Returns: all of the nodes contained in this array Type NodeArray getNodes() Source: graph_theory/edge_array.js, line 48 Returns: all of the nodes in this array of edges Type NodeArray × Search results Close "},"module-GraphTheory.Graph.html":{"id":"module-GraphTheory.Graph.html","title":"Class: Graph","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Graph GraphTheory. Graph represents a Graph new Graph(nodes) creates a Graph object Parameters: Name Type Description nodes NodeArray the graph's nodes Source: graph_theory/graph.js, line 12 Members components :ComponentArray the graph's components Type: ComponentArray Source: graph_theory/graph.js, line 65 edges :EdgeArray the graph's edges Type: EdgeArray Source: graph_theory/graph.js, line 55 nodes :NodeArray the graph's nodes Type: NodeArray Source: graph_theory/graph.js, line 45 Methods &lt;static&gt; assignEdgeArray(EAClass) defines EdgeArrayClass (and associated dependencies) on the Prototype chain for runtime extension Parameters: Name Type Description EAClass function the EdgeArray function this class depends upon Source: graph_theory/graph.js, line 18 Returns: the updated Graph class Type function addComponent(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph.js, line 297 addEdge(edgeArg) copies the nodes from the edge, then adds it to the edges array Parameters: Name Type Description edgeArg Edge Source: graph_theory/graph.js, line 144 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#removeElement Returns: the current graph Type Graph addNode() Source: graph_theory/graph.js, line 70 See: [delegated to NodeArray#push] module:GraphTheory.NodeArray#push bfs(initNode) breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node Parameters: Name Type Description initNode Node inital node Source: graph_theory/graph.js, line 339 Returns: a key-value store of nodes and edge distances Type Map clearEdges() Source: graph_theory/graph.js, line 165 See: [delegated to EdgeArray#clear] module:GraphTheory.EdgeArray#clear Returns: the current graph Type Graph clearNodes() removes all edges associated with the argument, then removes all nodes the node Source: graph_theory/graph.js, line 96 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#clear [remove edge] module:GraphTheory.Graph#removeEdge Returns: the current graph Type Graph containsEdge() Source: graph_theory/graph.js, line 152 See: [delegated to EdgeArray#push] module:GraphTheory.EdgeArray#push containsNode() Source: graph_theory/graph.js, line 77 See: [delegated NodeArray#contains] module:GraphTheory.NodeArray#contains copyEdges(eArr) copies and merges the nodes from the edgeArray, then merges the edges into the current graph Parameters: Name Type Description eArr EdgeArray Source: graph_theory/graph.js, line 187 Returns: the modified graph Type Graph copyNodes(nArr) merges the nodes from the argument into the current graphs nodes Parameters: Name Type Description nArr NodeArray nodes to merge Source: graph_theory/graph.js, line 116 Returns: the current graph Type Graph createEdge(sNode, dNode, weight) creates a new edge given two nodes Parameters: Name Type Description sNode Node source node dNode Node destination node weight Number weight of new edge Source: graph_theory/graph.js, line 134 Returns: the newly added edge Type Edge dfs(initNode) depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the initNode Parameters: Name Type Description initNode Node the source node Source: graph_theory/graph.js, line 277 Returns: a key-value store of nodes and edge distances Type Map dijkstra(initNode) performs dijkstras algorithm for shortest paths to all nodes reachable from initNode Parameters: Name Type Description initNode Node the initial node Source: graph_theory/graph.js, line 378 Returns: a sequence of nodes and their distances Type Map edgesWithNode(nodeArg) Parameters: Name Type Description nodeArg Node source node Source: graph_theory/graph.js, line 124 Returns: the edges connected to source Type EdgeArray establishComponents() assigns/typecasts the components attibute Source: graph_theory/graph.js, line 60 establishEdges() assigns/typecasts the edges attibute Source: graph_theory/graph.js, line 50 establishNodes(nArr) assigns/typecasts the nodes attibute Parameters: Name Type Argument Description nArr NodeArray &lt;nullable&gt; Source: graph_theory/graph.js, line 40 findIntersectingComponent(compArg) returns any current components which intersect with the specified component Parameters: Name Type Description compArg NodeArray the component to be checked Source: graph_theory/graph.js, line 308 Returns: the first intersecting component Type NodeArray getNeighbors(nodeArg) Parameters: Name Type Description nodeArg Node the source node Source: graph_theory/graph.js, line 215 Returns: the neighboring nodes Type NodeArray getUnvisitedEdges(nodeArg, compArg) returns all of the Edges connected to a node whose neighbors have yet to be visited Parameters: Name Type Description nodeArg Node the node compArg NodeArray the component being explored Source: graph_theory/graph.js, line 232 Returns: the edges with unexplored nodes Type EdgeArray getUnvisitedNeighbors(nodeArg, compArg) returns all of the nodes neighbors not yet part explored in the component Parameters: Name Type Description nodeArg Node compArg NodeArray the explored component Source: graph_theory/graph.js, line 242 Returns: unexplored nodes Type NodeArray hasIntersectingComponent(compArg) checks if any current components share nodes with the argument Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph.js, line 331 Returns: Type Boolean hasPath(initNode, termNode) check if a path exists between two nodes Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graph_theory/graph.js, line 370 Returns: does a path exist between the two nodes Type Boolean integrateComponent(compArg) integrates a component into any of the graphs intersectung components Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph.js, line 323 mergeComponents(origComp, newComp) combines the nodes of two intersecting components Parameters: Name Type Description origComp NodeArray newComp NodeArray Source: graph_theory/graph.js, line 316 pathNodes(pathArg) typecasts a path to a NodeArray Parameters: Name Type Description pathArg Map an ordered sequence of nodes with predecessors and path weights Source: graph_theory/graph.js, line 223 Returns: An array of the nodes Type NodeArray removeEdge() Source: graph_theory/graph.js, line 158 See: [delegated to EdgeArray#removeElement] module:GraphTheory.EdgeArray#removeElement removeNode() removes all edges associated with the argument, then calls removes the node Source: graph_theory/graph.js, line 85 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#removeElement [remove edge] module:GraphTheory.Graph#removeEdge setEdges(eArr) clears and reassigns nodes to those of the edge array, and sets the edges functions basically as a graph reset, an easy way to explore a graph from different angles Parameters: Name Type Description eArr EdgeArray Source: graph_theory/graph.js, line 176 See: [calls EdgeArray#getNodes] module:GraphTheory.EdgeArray#getNodes Returns: the modified graph Type Graph setNodes(nArr) clears the nodes and reassigns them to narr Parameters: Name Type Description nArr NodeArray Source: graph_theory/graph.js, line 106 Returns: the current graph Type Graph shortestPath(initNode, termNode) composes the shortest path between two nodes by backtracing from dijkstra Parameters: Name Type Description initNode Node termNode Node Source: graph_theory/graph.js, line 415 Returns: path of nodes Type Map subGraph(nArr) creates a new graph Parameters: Name Type Argument Description nArr NodeArray &lt;nullable&gt; a potential inital set of Nodes Source: graph_theory/graph.js, line 198 Returns: a new Graph instance Type Graph subGraphByEdges( [eArr]) creates a new graph, and sets its edges, useful for exploring a graph based on different connections Parameters: Name Type Argument Default Description eArr EdgeArray &lt;optional&gt; this.edges a potential inital set of Edges Source: graph_theory/graph.js, line 207 Returns: a new Graph instance Type Graph visitPath(pathArg) adds all unvisited nodes in the path to the specified component Parameters: Name Type Description pathArg Map the path to be explored Source: graph_theory/graph.js, line 249 × Search results Close "},"module-GraphTheory.Node.html":{"id":"module-GraphTheory.Node.html","title":"Class: Node","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Node GraphTheory. Node represent a Node new Node(label, data) Parameters: Name Type Description label String label property data Object the nodes data Source: graph_theory/node.js, line 9 Methods isEquivalent(newNode) Checks for identity via label attribute Parameters: Name Type Description newNode Node the node to be compared Source: graph_theory/node.js, line 41 Returns: Type Boolean setData(d) sets the node's data attribute Parameters: Name Type Description d Object Source: graph_theory/node.js, line 29 setLabel(lbl) sets the node's label attribute Parameters: Name Type Description lbl String Source: graph_theory/node.js, line 18 × Search results Close "},"module-GraphTheory.NodeArray.html":{"id":"module-GraphTheory.NodeArray.html","title":"Class: NodeArray","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: NodeArray GraphTheory. NodeArray represents a set of Nodes new NodeArray() Source: graph_theory/node_array.js, line 10 Extends RobustArray Methods &lt;static&gt; assignNode(NClass) defines NodeClass on the Prototype chain for runtime extension Parameters: Name Type Description NClass function the Node function this class depends upon Source: graph_theory/node_array.js, line 16 Returns: the updated NodeArray class Type function × Search results Close "},"module-GraphTheory.RobustArray.html":{"id":"module-GraphTheory.RobustArray.html","title":"Class: RobustArray","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: RobustArray GraphTheory. RobustArray a type-specific array class implementing set theory new RobustArray() Source: graph_theory/robust_array.js, line 15 Extends Array Methods RobustArray#clear(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 152 Returns: the newly empty array Type RobustArray RobustArray#concat(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#concat arguments Source: graph_theory/robust_array.js, line 84 Returns: Type RobustArray RobustArray#contains(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array.js, line 41 Returns: Type Boolean RobustArray#copy() Source: graph_theory/robust_array.js, line 161 Returns: a copy of this array Type RobustArray RobustArray#difference(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array.js, line 201 Returns: the unshared elements Type RobustArray RobustArray#excludeElement(exElem) Parameters: Name Type Description exElem Object the element to exclude Source: graph_theory/robust_array.js, line 234 Returns: all of the elements in this object excluding exElem Type RobustArray RobustArray#filter(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#filter arguments Source: graph_theory/robust_array.js, line 64 Returns: Type RobustArray RobustArray#findEquivalentElement(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 131 Returns: Type Object RobustArray#hasDistinctElements(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array.js, line 191 Returns: does the caller have any element not included in the argument Type Boolean RobustArray#hasSameSize(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 103 Returns: do the arrays have the same length Type Boolean RobustArray#intersection(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array.js, line 182 Returns: the shared elements Type RobustArray RobustArray#intersects(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array.js, line 171 Returns: Type Boolean RobustArray#isEmpty() Source: graph_theory/robust_array.js, line 31 Returns: is the array length 0 Type Boolean RobustArray#isEquivalent(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 121 Returns: do the argument nad receiver share length and elements Type Boolean RobustArray#isSubset(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 112 Returns: does the altArray contain every element of the receiver Type Boolean RobustArray#isValid(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array.js, line 23 Returns: Type Boolean RobustArray#push(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array.js, line 51 Returns: the current array Type RobustArray RobustArray#removeElement(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array.js, line 141 Returns: Type Object | Boolean RobustArray#slice(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#slice arguments Source: graph_theory/robust_array.js, line 74 Returns: Type RobustArray RobustArray#splice(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#splice arguments Source: graph_theory/robust_array.js, line 94 Returns: Type RobustArray RobustArray#union(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 211 Returns: Type RobustArray RobustArray#unionize(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array.js, line 224 Returns: the receiver Type RobustArray × Search results Close "},"module-RobustArrayFactory.html":{"id":"module-RobustArrayFactory.html","title":"Module: RobustArrayFactory","body":" DocStrap Modules GraphTheoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: RobustArrayFactory A RobustArrayFactory Source: graph_theory/robust_array.js, line 246 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
